<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Art Gallery</title>
    <style>
        body {
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            touch-action: none;  /* Prevent default touch actions */
            background: #000;
        }

        #scene-container { 
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #1E90FF);
        }

        #controls-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: 'Minecraft', monospace;
            font-size: 14px;
            text-shadow: 2px 2px #000;
            background: none;
            padding: 0;
            border: none;
            pointer-events: none;
            z-index: 1000;
            line-height: 1.4;
        }

        #controls-info p {
            margin: 4px 0;
        }

        #artwork-info {
            display: none;  /* Hide artwork info element */
        }

        .train-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .train-prompt.visible {
            opacity: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }

        .fade-out {
            animation: fadeOut 0.5s ease forwards;
        }

        #welcome-popup {
            position: fixed;
            top: 40%;  /* Changed from 50% to 40% to move it higher */
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            width: min(90%, 500px);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
            visibility: visible;
        }

        #welcome-popup.visible {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
        }

        #welcome-popup.fade-out {
            opacity: 0;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .welcome-title {
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 500;
            margin: 0;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1.3;
        }

        .artist-credit {
            font-size: clamp(0.9rem, 3vw, 1rem);
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .copyright {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .welcome-links {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .nodeco {
            color: #4a9eff;
            text-decoration: none;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            transition: color 0.2s ease;
            display: inline;
            padding: 0;
            background: none;
            border: none;
        }

        .nodeco:hover {
            color: #7ab8ff;
            text-decoration: underline;
            transform: none;
        }

        .nodeco:active {
            color: #2d7edb;
        }

        @media (max-width: 768px) {
            #welcome-popup {
                padding: 1.5rem;
                bottom: 20%;
            }

            .welcome-title {
                font-size: 1.5rem;
                letter-spacing: 1.5px;
            }

            .nodeco {
                font-size: 0.85rem;
            }
        }

        /* Mobile Controls */
        #joystick {
            display: none;
        }
        
        @media (max-width: 768px) {
            #controls-info {
                display: none;  /* Hide desktop controls info on mobile */
            }

            /* Improve mobile UI elements */
            #artwork-info {
                font-size: 16px;
                padding: 20px;
                max-width: 90%;
                margin: 20px auto;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
            }

            /* Add train boarding button */
            #train-button {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                color: #333;
                cursor: pointer;
                z-index: 1000;
                border: 2px solid rgba(0, 0, 0, 0.2);
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                opacity: 0;
                transition: opacity 0.3s ease;
            }

            #train-button.visible {
                opacity: 1;
            }

            #train-button.active {
                background: rgba(76, 175, 80, 0.8);
                color: white;
            }
        }

        #center-dot {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1px;
            height: 1px;
            background-color: black;
            z-index: 1000;
        }
        .artwork-description {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        .artwork-description h3 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .artwork-description p {
            margin: 0;
            color: #666;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="center-dot"></div>
    <div id="train-button">ðŸš‚</div>
    <div id="welcome-popup" class="visible">
        <h1 class="welcome-title">Entropy Emergence through Repetition</h1>
        <div class="artist-credit">
            Pen and Pencil Doodle Art Exhibition by 
            <a href='https://www.youtube.com/@tortorken' class="nodeco">imtortorken</a>
            <span class="copyright">Â© 2025</span>
        </div>
        <div class="welcome-links">
            <a href='https://buymeacoffee.com/beatsaway' class="nodeco">â˜• Support this artist</a>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "./three/three.module.min.js",
                "three/addons/": "./three/examples/jsm/"
            }
        }
    </script>
    <script src="images/artworkDescriptions.js"></script>
    <script src="controls.js"></script>
    <script src="three.min.js"></script>
    
    <script src="OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.userData.galleryWidth = 20 * 5;  // Scaled up 5x
        scene.userData.galleryLength = 100 * 5;  // Scaled up 5x
        scene.userData.galleryHeight = 8 * 5;  // Scaled up 5x
        const wallThickness = 0.2 * 5;
        const corridorWidth = 6 * 5;
        
        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Scene setup
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: isMobile ? false : true,
            powerPreference: isMobile ? "low-power" : "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // Movement and controls
        const controls = new GalleryControls(camera, scene);
        controls.setupEventListeners();
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();
        let walkCycle = 0;  // For bobbing motion

        // Train system setup
        const trainSystem = {
            carts: [],
            track: null,
            speed: 0.05,  // Reduced from 0.1 to 0.05 (2 times slower)
            direction: 1,
            currentPosition: 0
        };
        
        // Current artwork display element
        const controlsInfoElement = document.getElementById('controls-info');
        const artworkInfoElement = document.getElementById('artwork-info');
        
        // Create artwork materials with different colors
        const artworkMaterials = [];
        for (let i = 1; i <= 19; i++) {
            // Create a random color for each artwork
            const color = new THREE.Color(
                Math.random() * 0.5 + 0.5,  // R: 0.5-1.0
                Math.random() * 0.5 + 0.5,  // G: 0.5-1.0
                Math.random() * 0.5 + 0.5   // B: 0.5-1.0
            );
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                side: THREE.DoubleSide
            });
            artworkMaterials.push(material);
        }

        // Create a fallback material in case of any issues
        function createFallbackMaterial() {
            return new THREE.MeshBasicMaterial({ 
                color: 0xcccccc,
                side: THREE.DoubleSide
            });
        }
        
        // Update artwork titles
        const artworkTitles = [];
        for (let i = 1; i <= 19; i++) {
            artworkTitles.push(`Piece ${i}`);
        }
        
        // NPCs
        const npcs = [];
        const npcCount = 24;  // Increased from 12 to 24 NPCs

        function createCuteMinecraftVillager() {
            const group = new THREE.Group();
            const scale = 0.5;  // Half the original size

            // Give each group some random colors
            const skinColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const clothesColor = new THREE.Color(Math.random(), Math.random(), Math.random());

            const headGeometry = new THREE.BoxGeometry(1 * scale, 1 * scale, 1 * scale);
            const headMaterial = new THREE.MeshBasicMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.8 * scale;
            group.add(head);

            const bodyGeometry = new THREE.BoxGeometry(0.8 * scale, 0.8 * scale, 0.5 * scale);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: clothesColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0;
            group.add(body);

            const armGeometry = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-0.55 * scale, 0, 0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(0.55 * scale, 0, 0);
            group.add(rightArm);

            const legGeometry = new THREE.BoxGeometry(0.3 * scale, 0.5 * scale, 0.3 * scale);
            const pantsMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(clothesColor).multiplyScalar(0.7)
            });
            const leftLeg = new THREE.Mesh(legGeometry, pantsMaterial);
            leftLeg.position.set(-0.2 * scale, -0.65 * scale, 0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, pantsMaterial);
            rightLeg.position.set(0.2 * scale, -0.65 * scale, 0);
            group.add(rightLeg);

            // Add random walking style parameters
            group.userData.walkStyle = {
                frequency: 0.8 + Math.random() * 0.4,  // Random walking speed
                legAmplitude: 0.3 + Math.random() * 0.4,  // Random leg swing
                armAmplitude: 0.2 + Math.random() * 0.5,  // Random arm swing
                bodyTilt: (Math.random() - 0.5) * 0.1,  // Slight random body tilt
                headBob: 0.05 + Math.random() * 0.1,  // Random head bobbing
                swayAmount: Math.random() * 0.1  // Random side-to-side sway
            };

            return group;
        }

        function createNPC() {
            const npc = createCuteMinecraftVillager();
            
            // Random starting position within the gallery
            const x = (Math.random() - 0.5) * (scene.userData.galleryWidth - 2);
            const z = -scene.userData.galleryLength / 2 + 5 + Math.random() * (scene.userData.galleryLength - 10);
            npc.position.set(x, 0.65, z);  // Adjusted Y position for smaller size
            
            // Add random movement properties
            npc.userData.velocity = new THREE.Vector3();
            npc.userData.direction = new THREE.Vector3(
                Math.random() - 0.5,
                0,
                Math.random() - 0.5
            ).normalize();
            npc.userData.speed = 0.2 + Math.random() * 0.5;  // More varied speeds
            npc.userData.changeDirectionTime = Math.random() * 8000;
            npc.userData.lastDirectionChange = performance.now();
            npc.userData.walkCycle = Math.random() * Math.PI * 2;
            npc.userData.pauseTime = 0;  // For random pausing
            npc.userData.isPaused = false;
            
            scene.add(npc);
            npcs.push(npc);
            return npc;
        }

        // Create initial NPCs
        for (let i = 0; i < npcCount; i++) {
            createNPC();
        }

        function updateNPCs(time) {
            for (const npc of npcs) {
                // Random pausing behavior
                if (!npc.userData.isPaused) {
                    if (Math.random() < 0.001) {  // Small chance to pause
                        npc.userData.isPaused = true;
                        npc.userData.pauseTime = time + Math.random() * 3000;  // Pause for 0-3 seconds
                    }
                } else if (time > npc.userData.pauseTime) {
                    npc.userData.isPaused = false;
                }

                if (!npc.userData.isPaused) {
                    // Change direction randomly or when near walls
                    if (time - npc.userData.lastDirectionChange > npc.userData.changeDirectionTime) {
                        const angle = Math.random() * Math.PI * 2;
                        npc.userData.direction.set(
                            Math.cos(angle),
                            0,
                            Math.sin(angle)
                        ).normalize();
                        npc.userData.changeDirectionTime = 3000 + Math.random() * 8000;
                        npc.userData.lastDirectionChange = time;
                    }
                    
                    // Calculate new position
                    const newPosition = npc.position.clone();
                    newPosition.x += npc.userData.direction.x * npc.userData.speed * 0.02;
                    newPosition.z += npc.userData.direction.z * npc.userData.speed * 0.02;
                    
                    // Boundary checks using gallery dimensions
                    const margin = 1;
                    const maxX = scene.userData.galleryWidth/2 - margin;
                    const maxZ = scene.userData.galleryLength/2 - margin;
                    
                    // Clamp position to gallery boundaries
                    newPosition.x = Math.max(-maxX, Math.min(maxX, newPosition.x));
                    newPosition.z = Math.max(-maxZ, Math.min(maxZ, newPosition.z));
                    
                    // Update position and rotation
                        npc.position.copy(newPosition);
                        npc.rotation.y = Math.atan2(npc.userData.direction.x, npc.userData.direction.z);
                        
                        // Apply walking style
                        const style = npc.userData.walkStyle;
                        npc.userData.walkCycle += style.frequency * 0.1;
                        
                        // Leg animation with unique style
                        const leftLeg = npc.children[4];
                        const rightLeg = npc.children[5];
                        leftLeg.rotation.x = Math.sin(npc.userData.walkCycle) * style.legAmplitude;
                        rightLeg.rotation.x = Math.sin(npc.userData.walkCycle + Math.PI) * style.legAmplitude;
                        
                        // Arm animation with unique style
                        const leftArm = npc.children[2];
                        const rightArm = npc.children[3];
                        leftArm.rotation.x = Math.sin(npc.userData.walkCycle + Math.PI) * style.armAmplitude;
                        rightArm.rotation.x = Math.sin(npc.userData.walkCycle) * style.armAmplitude;
                        
                        // Body and head movement
                        const body = npc.children[1];
                        const head = npc.children[0];
                        body.rotation.z = Math.sin(npc.userData.walkCycle * 2) * style.swayAmount + style.bodyTilt;
                        head.rotation.x = Math.sin(npc.userData.walkCycle * 2) * style.headBob;
                } else {
                    // Reset animations while paused
                    npc.children.forEach(part => part.rotation.set(0, 0, 0));
                }
            }
        }
        
        // Create the gallery environment
        function createGallery() {
            // Floor with meadow appearance
            createFloor();

            // Ceiling as a single large plane
            const ceilingGeometry = new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryLength);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                map: baseWoodTexture.clone(),
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            ceilingMaterial.map.wrapS = THREE.RepeatWrapping;
            ceilingMaterial.map.wrapT = THREE.RepeatWrapping;
            ceilingMaterial.map.repeat.set(1, 3); // Adjust as needed
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = scene.userData.galleryHeight;
            ceiling.rotation.x = Math.PI / 2;
            ceiling.receiveShadow = true;
            scene.add(ceiling);

            // Walls
            createWalls();
            
            // Artworks
            placeArtworks();
            
            // Lights
            createLights();
            
            // Add railway system
            createRailwaySystem();
        }
        
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryLength);
            const textureLoader = new THREE.TextureLoader();
            const woodTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(40, 40);  // Increased from 8,8 to 40,40 for 5x smaller pattern
            
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }
        
        // Load the wood texture once at the top
        const textureLoader = new THREE.TextureLoader();
        const baseWoodTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
        baseWoodTexture.wrapS = THREE.RepeatWrapping;
        baseWoodTexture.wrapT = THREE.RepeatWrapping;

        // Load the crate texture once at the top
        const crateTexture = textureLoader.load('https://threejs.org/examples/textures/crate.gif');
        crateTexture.wrapS = THREE.RepeatWrapping;
        crateTexture.wrapT = THREE.RepeatWrapping;

        function createWalls() {
            const wallTexture = baseWoodTexture.clone();
            wallTexture.repeat.set(20, 1);
            const wallMaterial = new THREE.MeshStandardMaterial({
                map: wallTexture,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });

            // Create back wall
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryHeight),
                wallMaterial
            );
            backWall.position.set(0, scene.userData.galleryHeight/2, -scene.userData.galleryLength/2);
            backWall.receiveShadow = true;
            backWall.material.map.repeat.set(2, 1);
            scene.add(backWall);

            // Create side walls
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(scene.userData.galleryLength, scene.userData.galleryHeight),
                wallMaterial
            );
            leftWall.position.x = -scene.userData.galleryWidth/2;
            leftWall.position.y = scene.userData.galleryHeight/2;
            leftWall.rotation.y = Math.PI/2;
            leftWall.receiveShadow = true;
            leftWall.material.map.repeat.set(1, 1);
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(scene.userData.galleryLength, scene.userData.galleryHeight),
                wallMaterial
            );
            rightWall.position.x = scene.userData.galleryWidth/2;
            rightWall.position.y = scene.userData.galleryHeight/2;
            rightWall.rotation.y = -Math.PI/2;
            rightWall.receiveShadow = true;
            rightWall.material.map.repeat.set(1, 1);
            scene.add(rightWall);

            // Create front wall
            const frontWall = new THREE.Mesh(
                new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryHeight),
                wallMaterial
            );
            frontWall.position.set(0, scene.userData.galleryHeight/2, scene.userData.galleryLength/2);
            frontWall.receiveShadow = true;
            frontWall.material.map.repeat.set(2, 1);
            scene.add(frontWall);
        }
        
        // At the top of your script, define the artwork image paths
        const artworkImagePaths = [];
        for (let i = 1; i <= 19; i++) {
            artworkImagePaths.push(`images/piece${i}.jpg`);
        }

        // Load artwork descriptions from artworkDescriptions.js if available
        // (Assume artworkDescriptions is a global array)

        function createFramedArtwork(texture, width, height, title, index) {
            const artworkGroup = new THREE.Group();

            // Artwork mesh with image texture
            const artworkGeometry = new THREE.PlaneGeometry(width, height);
            const artworkMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                side: THREE.DoubleSide
            });
            const artwork = new THREE.Mesh(artworkGeometry, artworkMaterial);
            artworkGroup.add(artwork);

            // --- Create the sign with parsed title and description ---
            const signWidth = width * 0.4;  // Reduced from 0.5 to 0.4
            const signHeight = height * 0.1;  // Reduced from 0.2 to 0.15
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 180;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#222';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            let parsed = { title, description: title };
            if (typeof parseArtworkDescription === 'function') {
                parsed = parseArtworkDescription(index);
            } else if (typeof artworkDescriptions !== 'undefined' && artworkDescriptions[index]) {
                // Fallback: try to extract title/desc manually
                const description = artworkDescriptions[index];
                const descLines = description.split('\n');
                parsed = {
                    title: descLines[0].replace(/\*\*/g, '') || title,
                    description: descLines[1] || title
                };
            }

            // Calculate text metrics for centering
            const titleFont = 'bold 20px "Playfair Display", "Times New Roman", serif';
            const descFont = '14px "Playfair Display", "Times New Roman", serif';
            
            // Draw title
            ctx.font = titleFont;
            const titleMetrics = ctx.measureText(parsed.title);
            ctx.fillText(parsed.title, canvas.width / 2, 30);

            // Draw wrapped description
            ctx.font = descFont;
            const lineHeight = 20;
            const maxWidth = 440;
            const lines = wrapText(ctx, parsed.description, maxWidth);
            const totalDescHeight = lines.length * lineHeight;
            
            // Calculate starting position for description to center the entire block
            const startY = 60 + (canvas.height - 60 - totalDescHeight) / 2;
            
            // Draw each line of the description
            lines.forEach((line, index) => {
                ctx.fillText(line, canvas.width / 2, startY + (index * lineHeight));
            });

            const signTexture = new THREE.CanvasTexture(canvas);
            const signGeometry = new THREE.PlaneGeometry(signWidth, signHeight);
            const signMaterial = new THREE.MeshBasicMaterial({ 
                map: signTexture,
                side: THREE.DoubleSide,
                transparent: true
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, -height/2 - signHeight/2 - 0.2, 0);
            artworkGroup.add(sign);

            return artworkGroup;
        }
        
        // Helper function to wrap text on canvas
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;
                if (width < maxWidth) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }
        
        function placeArtworks() {
            const artworks = [];
            const artworkWidth = 3.5 * 5;    // Scaled up 5x
            const artworkHeight = 4.5 * 5;   // Scaled up 5x
            const artworkSpacing = 8 * 5;    // Scaled up 5x
            const artworkWallOffset = 0.12 * 5; // Scaled up 5x
            const artworkYPosition = artworkHeight / 2 + 3;  // Increased from 2.8 to 3

            const textureLoader = new THREE.TextureLoader();
            const artworkTextures = artworkImagePaths.map(path => textureLoader.load(path));

            // Place artworks on left wall (facing right)
            for (let i = 0; i < 9; i++) {
                const artwork = createFramedArtwork(
                    artworkTextures[i],
                    artworkWidth, 
                    artworkHeight, 
                    artworkTitles[i],
                    i
                );
                const zPos = -scene.userData.galleryLength / 2 + 10 + i * artworkSpacing;
                artwork.position.set(
                    -scene.userData.galleryWidth / 2 + artworkWallOffset + 0.001, 
                    artworkYPosition, 
                    zPos
                );
                artwork.rotation.y = Math.PI / 2;  // Rotate to face right
                scene.add(artwork);
                artworks.push(artwork);
            }

            // Place artworks on right wall (facing left)
            for (let i = 0; i < 10; i++) {
                const artwork = createFramedArtwork(
                    artworkTextures[i + 9],
                    artworkWidth, 
                    artworkHeight, 
                    artworkTitles[i + 9],
                    i + 9
                );
                const zPos = -scene.userData.galleryLength / 2 + 10 + i * artworkSpacing;
                artwork.position.set(
                    scene.userData.galleryWidth / 2 - artworkWallOffset - 0.001, 
                    artworkYPosition, 
                    zPos
                );
                artwork.rotation.y = -Math.PI / 2;  // Rotate to face left
                scene.add(artwork);
                artworks.push(artwork);
            }
            return artworks;
        }
        
        function createLights() {
            // Ambient light - increased intensity
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);  // Increased from 0.5 to 1.0
            scene.add(ambientLight);
            
            // Add fewer spotlights to light the gallery (to reduce shader complexity)
            const spotlightColor = 0xffffff;
            const spotlightIntensity = 5;  // Increased from 3 to 5
            const spotlightDistance = 30;  // Increased from 20 to 30
            const spotlightAngle = Math.PI / 4;  // Widened angle
            const spotlightPenumbra = 0.7;  // Increased softness
            
            // Use fewer spotlights - just 3 per wall to reduce shader complexity
            // Left wall spotlights
            const leftPositions = [-scene.userData.galleryLength / 3, 0, scene.userData.galleryLength / 3];
            for (let i = 0; i < leftPositions.length; i++) {
                const zPos = leftPositions[i];
                
                const spotlight = new THREE.SpotLight(
                    spotlightColor, 
                    spotlightIntensity, 
                    spotlightDistance, 
                    spotlightAngle, 
                    spotlightPenumbra
                );
                
                spotlight.position.set(-scene.userData.galleryWidth / 2 + 2, scene.userData.galleryHeight - 0.5, zPos);
                spotlight.target.position.set(-scene.userData.galleryWidth / 2 + 0.1, 0, zPos);  // Point lower
                
                spotlight.castShadow = true;
                spotlight.shadow.bias = -0.0001;
                spotlight.shadow.mapSize.width = 1024;  // Increased shadow quality
                spotlight.shadow.mapSize.height = 1024;
                
                scene.add(spotlight);
                scene.add(spotlight.target);
            }
            
            // Right wall spotlights
            const rightPositions = [-scene.userData.galleryLength / 3, 0, scene.userData.galleryLength / 3];
            for (let i = 0; i < rightPositions.length; i++) {
                const zPos = rightPositions[i];
                
                const spotlight = new THREE.SpotLight(
                    spotlightColor, 
                    spotlightIntensity, 
                    spotlightDistance, 
                    spotlightAngle, 
                    spotlightPenumbra
                );
                
                spotlight.position.set(scene.userData.galleryWidth / 2 - 2, scene.userData.galleryHeight - 0.5, zPos);
                spotlight.target.position.set(scene.userData.galleryWidth / 2 - 0.1, 0, zPos);  // Point lower
                
                spotlight.castShadow = true;
                spotlight.shadow.bias = -0.0001;
                spotlight.shadow.mapSize.width = 1024;  // Increased shadow quality
                spotlight.shadow.mapSize.height = 1024;
                
                scene.add(spotlight);
                scene.add(spotlight.target);
            }
            
            // Simplify the main lighting - use a hemispherical light instead of directional
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x404040, 1.2);  // Increased from 0.8 to 1.2
            scene.add(hemisphereLight);
        }
        
        // Add train and railway system
        function createRailwaySystem() {
            // Parameters for rail placement
            const railSeparation = 1.2; // Distance between the two rails
            const railWidth = 0.15;     // Width of each rail
            const railHeight = 0.1;
            const railLength = scene.userData.galleryLength;

            // Create left rail
            const leftRailGeometry = new THREE.BoxGeometry(railWidth, railHeight, railLength);
            const leftRailTexture = crateTexture.clone();
            leftRailTexture.repeat.set(1, 40);
            const leftRailMaterial = new THREE.MeshStandardMaterial({
                map: leftRailTexture,
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            const leftRail = new THREE.Mesh(leftRailGeometry, leftRailMaterial);
            leftRail.position.set(-railSeparation / 2, 0.05, 0);
            scene.add(leftRail);

            // Create right rail
            const rightRailGeometry = new THREE.BoxGeometry(railWidth, railHeight, railLength);
            const rightRailTexture = crateTexture.clone();
            rightRailTexture.repeat.set(1, 40);
            const rightRailMaterial = new THREE.MeshStandardMaterial({
                map: rightRailTexture,
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            const rightRail = new THREE.Mesh(rightRailGeometry, rightRailMaterial);
            rightRail.position.set(railSeparation / 2, 0.05, 0);
            scene.add(rightRail);

            // Create railway sleepers
            const sleeperGeometry = new THREE.BoxGeometry(2, 0.1, 0.4);
            const sleeperTexture = crateTexture.clone();
            sleeperTexture.repeat.set(2, 1);
            const sleeperMaterial = new THREE.MeshStandardMaterial({
                map: sleeperTexture,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            for (let z = -scene.userData.galleryLength/2 + 2; z < scene.userData.galleryLength/2 - 2; z += 2) {
                const sleeper = new THREE.Mesh(sleeperGeometry, sleeperMaterial);
                sleeper.position.set(0, 0.02, z);
                scene.add(sleeper);
            }

            // Create minecart train with 20 carts
            const cartSpacing = 2.5;  // Reduced spacing between carts
            for (let i = 0; i < 20; i++) {  // Changed from 10 to 20 carts
                const cart = createMinecart();
                cart.position.z = -scene.userData.galleryLength/2 + 5 + (i * cartSpacing);
                trainSystem.carts.push(cart);
                scene.add(cart);
            }

            // Update function for train movement
            trainSystem.update = function() {
                trainSystem.carts.forEach((cart, index) => {
                    // Move cart forward continuously
                    cart.position.z += trainSystem.speed;

                    // Implement room wrapping for train
                    const galleryLength = scene.userData.galleryLength;
                    const margin = 1; // Small margin to prevent getting stuck at edges

                    // Wrap Z position
                    if (cart.position.z > galleryLength/2 + margin) {
                        cart.position.z = -galleryLength/2 - margin;
                    } else if (cart.position.z < -galleryLength/2 - margin) {
                        cart.position.z = galleryLength/2 + margin;
                    }

                    // Rotate wheels continuously
                    cart.children.slice(3).forEach(wheel => {
                        wheel.rotation.x += 0.1 * trainSystem.speed;  // Simple wheel rotation
                    });

                    // Update camera if riding this cart
                    if (camera.userData.onTrain === cart) {
                        camera.position.x = cart.position.x;
                        camera.position.y = cart.position.y + 1.5;
                        camera.position.z = cart.position.z;
                    }
                });
            };
        }

        function createMinecart() {
            const cartGroup = new THREE.Group();
            const cartTexture = crateTexture.clone();
            cartTexture.repeat.set(2, 1);

            // Cart base
            const baseGeometry = new THREE.BoxGeometry(2, 0.5, 2);
            const baseMaterial = new THREE.MeshStandardMaterial({
                map: cartTexture,
                roughness: 0.7,
                metalness: 0.2
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5;
            cartGroup.add(base);

            // Cart sides
            const sideGeometry = new THREE.BoxGeometry(0.1, 0.5, 2);
            const sideMaterial = new THREE.MeshStandardMaterial({
                map: cartTexture,
                roughness: 0.7,
                metalness: 0.2
            });
            const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
            leftSide.position.set(-0.95, 1, 0);
            cartGroup.add(leftSide);
            const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
            rightSide.position.set(0.95, 1, 0);
            cartGroup.add(rightSide);

            // Cart wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({
                map: cartTexture,
                roughness: 0.7,
                metalness: 0.2
            });
            const wheelPositions = [
                [-0.8, 0.3, -0.8],
                [0.8, 0.3, -0.8],
                [-0.8, 0.3, 0.8],
                [0.8, 0.3, 0.8]
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.name = 'wheel';
                cartGroup.add(wheel);
            });
            return cartGroup;
        }
        
        function checkCollisions(position) {
            // Create a box representing the player
            const playerSize = 0.5;  // Half-width of player
            const playerHeight = 1.8;  // Height of player
            
            const playerMin = new THREE.Vector3(
                position.x - playerSize,
                position.y,
                position.z - playerSize
            );
            
            const playerMax = new THREE.Vector3(
                position.x + playerSize,
                position.y + playerHeight,
                position.z + playerSize
            );
            
            // Check collision with each wall
            for (const wall of collisionWalls) {
                // Check for intersection
                if (
                    playerMax.x > wall.min.x && playerMin.x < wall.max.x &&
                    playerMax.y > wall.min.y && playerMin.y < wall.max.y &&
                    playerMax.z > wall.min.z && playerMin.z < wall.max.z
                ) {
                    return true;  // Collision detected
                }
            }
            
            return false;  // No collision
        }
        
        // Set initial camera position (randomly positioned in front of an artwork)
        function setRandomInitialPosition() {
            // Decide which wall (left or right) randomly
            const isLeftWall = Math.random() < 0.5;
            
            // Calculate a random position along the wall
            const zPos = -scene.userData.galleryLength / 2 + 10 + Math.floor(Math.random() * 9) * (8 * 5);
            
            // Position camera in the middle of the corridor (x = 0)
            const xPos = 0;  // Middle of the corridor
            
            // Position camera
            camera.position.set(xPos, 0.8, zPos);
            
            // Make camera face the chosen wall
            if (isLeftWall) {
                camera.lookAt(new THREE.Vector3(-scene.userData.galleryWidth / 2, 0.8, zPos));
            } else {
                camera.lookAt(new THREE.Vector3(scene.userData.galleryWidth / 2, 0.8, zPos));
            }
        }

        // Initialize gallery, controls, and set random position
        createGallery();
        const galleryControls = new GalleryControls(camera, scene);
        setRandomInitialPosition();

        // Add click handler to remove welcome popup when clicking anywhere
            const welcomePopup = document.getElementById('welcome-popup');
        document.addEventListener('click', function() {
                welcomePopup.style.opacity = '0';
            welcomePopup.style.transform = 'translate(-50%, -50%)';
                setTimeout(() => {
                    welcomePopup.style.display = 'none';
            }, 300);
        }, { once: true });  // The 'once: true' option ensures the event only fires once

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
        // Add train boarding event listener
        document.addEventListener('keydown', (event) => {
            if (event.code === 'KeyE') {
                handleTrainBoarding();
            }
        });

        // Add mobile train button click handler
        const trainButton = document.getElementById('train-button');
        trainButton.addEventListener('click', handleTrainBoarding);

        function handleTrainBoarding() {
            const playerPos = camera.position;
            let nearestCart = null;
            let shortestDistance = Infinity;

            // Check if train system and carts exist
            if (!trainSystem || !trainSystem.carts || trainSystem.carts.length === 0) {
                return;
            }

            trainSystem.carts.forEach(cart => {
                if (!cart) return;
                
                const cartPos = cart.position;
                const distance = Math.sqrt(
                    Math.pow(playerPos.x - cartPos.x, 2) +
                    Math.pow(playerPos.z - cartPos.z, 2)
                );

                if (distance < shortestDistance) {
                    shortestDistance = distance;
                    nearestCart = cart;
                }
            });

            // Show/hide train button based on proximity or if already on train
            const trainButton = document.getElementById('train-button');
            if (shortestDistance < 3 || camera.userData.onTrain) {
                trainButton.classList.add('visible');
            } else {
                trainButton.classList.remove('visible');
                trainButton.classList.remove('active');
            }

            if (shortestDistance < 3 && nearestCart) {
                if (!camera.userData.onTrain) {
                    // Board train
                    camera.userData.onTrain = nearestCart;
                    camera.position.x = nearestCart.position.x + 0.5;
                    camera.position.y = nearestCart.position.y + 1.2;
                    camera.position.z = nearestCart.position.z;
                    if (artworkInfoElement) {
                        artworkInfoElement.innerHTML = "<strong>Tap ðŸš‚ to exit train</strong>";
                        artworkInfoElement.style.display = 'block';
                    }
                    trainButton.classList.add('active');
                } else {
                    // Exit train
                    camera.userData.onTrain = null;
                    camera.position.x = nearestCart.position.x + 2;
                    if (artworkInfoElement) {
                        artworkInfoElement.style.display = 'none';
                    }
                    trainButton.classList.remove('active');
                }
            }
        }
        
        // Add periodic check for train proximity
        function checkTrainProximity() {
            if (!isMobile) return; // Only check on mobile
            
            const playerPos = camera.position;
            let shortestDistance = Infinity;

            if (trainSystem && trainSystem.carts) {
                trainSystem.carts.forEach(cart => {
                    if (!cart) return;
                    
                    const cartPos = cart.position;
                    const distance = Math.sqrt(
                        Math.pow(playerPos.x - cartPos.x, 2) +
                        Math.pow(playerPos.z - cartPos.z, 2)
                    );

                    if (distance < shortestDistance) {
                        shortestDistance = distance;
                    }
                });
            }

            const trainButton = document.getElementById('train-button');
            if (shortestDistance < 3 || camera.userData.onTrain) {
                trainButton.classList.add('visible');
            } else {
                trainButton.classList.remove('visible');
                trainButton.classList.remove('active');
            }
        }

        // Add performance monitoring
        let frameCount = 0;
        let lastFPSUpdate = performance.now();
        
        function updateFPS() {
            const now = performance.now();
            const delta = now - lastFPSUpdate;
            
            if (delta >= 1000) {
                frameCount = 0;
                lastFPSUpdate = now;
            }
        }
        
        // Add movement update interval tracking
        let lastMovementUpdate = 0;
        const MOVEMENT_UPDATE_INTERVAL = 20; // 20ms = 0.02 seconds

        function animate() {
            requestAnimationFrame(animate);
            
            // Skip update if tab is hidden
            if (document.hidden) return;
            
            const time = performance.now();
            frameCount++;
            updateFPS();
            
            // Update NPCs
            updateNPCs(time);
            
            // Update train system
            if (trainSystem) {
                trainSystem.update();
            }
            
            // Update camera position if on train
            if (camera.userData.onTrain) {
                camera.position.z = camera.userData.onTrain.position.z;
            }
            
            // Check train proximity for mobile
            checkTrainProximity();
            
            // Update movement if active
            if (camera.userData.movement && time - lastMovementUpdate >= MOVEMENT_UPDATE_INTERVAL) {
                const speed = 0.5; // Base movement speed
                const movement = camera.userData.movement;
                
                // Update camera position based on stored movement values
                camera.position.x += movement.x * speed * movement.distance;
                camera.position.z += movement.z * speed * movement.distance;
                camera.position.y = 0.8; // Keep constant height
                
                lastMovementUpdate = time;
            }
            
            // Update controls with mobile input
            galleryControls.update();
            
            renderer.render(scene, camera);
        }
        
        // Track multiple touches
        let activeTouches = new Map();
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouching = false;
        const touchAreaRadius = 100; // Radius of the circular touch areas
        const touchAreaMargin = 20; // Margin from screen edges

        // Create visual indicators for touch areas
        const cameraTouchArea = document.createElement('div');
        cameraTouchArea.style.cssText = `
            position: fixed;
            bottom: ${touchAreaMargin}px;
            right: ${touchAreaMargin}px;
            width: ${touchAreaRadius * 2}px;
            height: ${touchAreaRadius * 2}px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        `;
        document.body.appendChild(cameraTouchArea);

        const movementTouchArea = document.createElement('div');
        movementTouchArea.style.cssText = `
            position: fixed;
            bottom: ${touchAreaMargin}px;
            left: ${touchAreaMargin}px;
            width: ${touchAreaRadius * 2}px;
            height: ${touchAreaRadius * 2}px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        `;
        document.body.appendChild(movementTouchArea);

        // Show indicators on mobile devices
        if (isMobile) {
            cameraTouchArea.style.display = 'block';
            movementTouchArea.style.display = 'block';
        }

        // Helper function to check if touch is within the camera control area
        function isTouchInCameraArea(touchX, touchY) {
            const centerX = window.innerWidth - touchAreaMargin - touchAreaRadius;
            const centerY = window.innerHeight - touchAreaMargin - touchAreaRadius;
            const distance = Math.sqrt(
                Math.pow(touchX - centerX, 2) + 
                Math.pow(touchY - centerY, 2)
            );
            return distance <= touchAreaRadius;
        }

        // Helper function to check if touch is within the movement control area
        function isTouchInMovementArea(touchX, touchY) {
            const centerX = touchAreaMargin + touchAreaRadius;
            const centerY = window.innerHeight - touchAreaMargin - touchAreaRadius;
            const distance = Math.sqrt(
                Math.pow(touchX - centerX, 2) + 
                Math.pow(touchY - centerY, 2)
            );
            return distance <= touchAreaRadius;
        }

        document.addEventListener('touchstart', (event) => {
            // Prevent default touch behavior
                    event.preventDefault();
            
            // Handle each new touch
            for (const touch of event.touches) {
                const touchId = touch.identifier;
                
                // Determine which area is being touched
                if (isTouchInMovementArea(touch.clientX, touch.clientY)) {
                    activeTouches.set(touchId, {
                        type: 'movement',
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    });
                    movementTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                    if (!galleryControls.isLocked) {
                        galleryControls.lock();
                    }
                } else if (isTouchInCameraArea(touch.clientX, touch.clientY)) {
                    activeTouches.set(touchId, {
                        type: 'camera',
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    });
                    if (!galleryControls.isLocked) {
                        galleryControls.lock();
                    }
                    cameraTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                }
            }
        });

        document.addEventListener('touchmove', (event) => {
            // Prevent default touch behavior
            event.preventDefault();
            
            // Handle each active touch
            for (const touch of event.touches) {
                const touchId = touch.identifier;
                const touchData = activeTouches.get(touchId);
                
                if (!touchData) continue;
                
                // Update current position
                touchData.currentX = touch.clientX;
                touchData.currentY = touch.clientY;
                
                // Calculate delta movement
                const deltaX = touchData.currentX - touchData.startX;
                const deltaY = touchData.currentY - touchData.startY;
                
                if (touchData.type === 'movement') {
                    // Calculate movement direction based on touch position relative to center
                    const centerX = touchAreaMargin + touchAreaRadius;
                    const centerY = window.innerHeight - touchAreaMargin - touchAreaRadius;
                    const relativeX = touchData.currentX - centerX;
                    const relativeY = touchData.currentY - centerY;
                    
                    // Calculate angle from center to touch position (flipped horizontally)
                    const angle = -Math.atan2(relativeY, relativeX);  // Added negative sign to flip horizontally
                    
                    // Calculate distance from center (0 to 1)
                    const distance = Math.min(1, Math.sqrt(relativeX * relativeX + relativeY * relativeY) / touchAreaRadius);
                    
                    // Get camera's forward direction
                    const cameraForward = new THREE.Vector3(0, 0, -1);
                    cameraForward.applyQuaternion(camera.quaternion);
                    
                    // Create a vector perpendicular to camera's forward direction
                    const cameraRight = new THREE.Vector3(1, 0, 0);
                    cameraRight.applyQuaternion(camera.quaternion);
                    
                    // Calculate movement direction relative to camera
                    const moveX = Math.cos(angle) * cameraRight.x + Math.sin(angle) * cameraForward.x;
                    const moveZ = Math.cos(angle) * cameraRight.z + Math.sin(angle) * cameraForward.z;
                    
                    // Normalize the movement vector
                    const moveLength = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    const normalizedMoveX = moveX / moveLength;
                    const normalizedMoveZ = moveZ / moveLength;
                    
                    // Store the movement values for the animation loop
                    camera.userData.movement = {
                        x: normalizedMoveX,
                        z: normalizedMoveZ,
                        distance: distance
                    };
                } else if (touchData.type === 'camera') {
                    // Update camera rotation
                    galleryControls.euler.setFromQuaternion(galleryControls.camera.quaternion);
                    galleryControls.euler.y -= deltaX * galleryControls.lookSpeed * 2;
                    galleryControls.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, 
                        galleryControls.euler.x - deltaY * galleryControls.lookSpeed * 2));
                    galleryControls.camera.quaternion.setFromEuler(galleryControls.euler);
                }
                
                // Update start position for next delta calculation
                touchData.startX = touchData.currentX;
                touchData.startY = touchData.currentY;
            }
        });

        document.addEventListener('touchend', (event) => {
            // Remove ended touches
            for (const touch of event.changedTouches) {
                const touchId = touch.identifier;
                const touchData = activeTouches.get(touchId);
                
                if (touchData) {
                    if (touchData.type === 'movement') {
                        movementTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    } else if (touchData.type === 'camera') {
                        cameraTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    }
                    activeTouches.delete(touchId);
                }
            }
            
            // Clear movement data if no movement touches remain
            if (!Array.from(activeTouches.values()).some(touch => touch.type === 'movement')) {
                camera.userData.movement = null;
            }
            
            // Unlock controls if no touches remain
            if (activeTouches.size === 0 && galleryControls.isLocked) {
                galleryControls.unlock();
            }
        });
        
            animate();
    </script>
</body>
</html>