<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Art Gallery</title>
    <style>
        body {
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            touch-action: none;  /* Prevent default touch actions */
            background: #000;
        }

        #scene-container { 
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #1E90FF);
        }

        #controls-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: 'Minecraft', monospace;
            font-size: 14px;
            text-shadow: 2px 2px #000;
            background: none;
            padding: 0;
            border: none;
            pointer-events: none;
            z-index: 1000;
            line-height: 1.4;
        }

        #controls-info p {
            margin: 4px 0;
        }

        #artwork-info {
            position: fixed;
            top: 20px;
            left: 20px;
            transform: none;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffffff;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 300px;
            text-align: left;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            transition: opacity 0.3s ease;
            z-index: 100;
        }

        #artwork-info h2 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #ffffff;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        #artwork-info p {
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            line-height: 1.6;
        }

        .train-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .train-prompt.visible {
            opacity: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }

        .fade-out {
            animation: fadeOut 0.5s ease forwards;
        }

        #welcome-popup {
            position: fixed;
            top: 40%;  /* Changed from 50% to 40% to move it higher */
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            width: min(90%, 500px);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
            visibility: visible;
        }

        #welcome-popup.visible {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
        }

        #welcome-popup.fade-out {
            opacity: 0;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .welcome-title {
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 500;
            margin: 0;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1.3;
        }

        .artist-credit {
            font-size: clamp(0.9rem, 3vw, 1rem);
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .copyright {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .welcome-links {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .nodeco {
            color: #4a9eff;
            text-decoration: none;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            transition: color 0.2s ease;
            display: inline;
            padding: 0;
            background: none;
            border: none;
        }

        .nodeco:hover {
            color: #7ab8ff;
            text-decoration: underline;
            transform: none;
        }

        .nodeco:active {
            color: #2d7edb;
        }

        @media (max-width: 768px) {
            #welcome-popup {
                padding: 1.5rem;
                bottom: 20%;
            }

            .welcome-title {
                font-size: 1.5rem;
                letter-spacing: 1.5px;
            }

            .nodeco {
                font-size: 0.85rem;
            }
        }

        /* Mobile Controls */
        #joystick {
            display: none;
        }
        
        @media (max-width: 768px) {
            #controls-info {
                display: none;  /* Hide desktop controls info on mobile */
            }

            /* Improve mobile UI elements */
            #artwork-info {
                font-size: 16px;
                padding: 20px;
                max-width: 90%;
                margin: 20px auto;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
            }
        }

        #center-dot {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1px;
            height: 1px;
            background-color: black;
            z-index: 1000;
        }
        .artwork-description {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        .artwork-description h3 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .artwork-description p {
            margin: 0;
            color: #666;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="center-dot"></div>
    <div id="welcome-popup" class="visible">
        <h1 class="welcome-title">Entropy Emergence through Repetition</h1>
        <div class="artist-credit">
            Pen and Pencil Doodle Art Exhibition by 
            <a href='https://www.youtube.com/@tortorken' class="nodeco">imtortorken</a>
            <span class="copyright">© 2025</span>
        </div>
        <div class="welcome-links">
            <a href='https://buymeacoffee.com/beatsaway' class="nodeco">☕ Support this artist</a>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "./three/three.module.min.js",
                "three/addons/": "./three/examples/jsm/"
            }
        }
    </script>
    <script type="module" src="./js/controls.js"></script>
    <script type="module" src="./js/artworkDescriptions.js"></script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GalleryControls } from './js/controls.js';
        import { artworkDescriptions } from './js/artworkDescriptions.js';
        
        // Function to parse artwork description
        function parseArtworkDescription(index) {
            const description = artworkDescriptions[index];
            if (!description) return { title: 'Unknown Artwork', description: 'No description available.' };
            
            // Extract title from markdown format (**Title**)
            const titleMatch = description.match(/\*\*(.*?)\*\*/);
            const title = titleMatch ? titleMatch[1] : 'Untitled';
            
            // Get description (everything after the title)
            const desc = description.split('\n')[1] || 'No description available.';
            
            return {
                title: title,
                description: desc
            };
        }
        
        // Enhanced error handling for module loading
        window.addEventListener('error', (event) => {
            console.error('Error loading module:', event.message);
            const errorMessage = document.createElement('div');
            errorMessage.style.cssText = `
                color: white;
                padding: 20px;
                text-align: center;
                background: rgba(0, 0, 0, 0.8);
                border-radius: 8px;
                margin: 20px;
            `;
            errorMessage.innerHTML = `
                    <h2>Error Loading Gallery</h2>
                <p>${event.message}</p>
                <p>Please check your browser console for details.</p>
                <p>If the problem persists, try:</p>
                <ul style="text-align: left; display: inline-block;">
                    <li>Refreshing the page</li>
                    <li>Using a different browser</li>
                    <li>Checking your internet connection</li>
                </ul>
            `;
            document.getElementById('scene-container').innerHTML = '';
            document.getElementById('scene-container').appendChild(errorMessage);
        });

        // Enhanced mobile device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEndDevice = isMobile && (
            /iPhone|iPad|iPod/i.test(navigator.userAgent) && 
            parseInt(navigator.userAgent.match(/OS (\d+)_/)[1]) < 13
        );

        // Add loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
        `;
        loadingIndicator.innerHTML = '<h2>Loading Gallery...</h2>';
        document.getElementById('scene-container').appendChild(loadingIndicator);

        // Add error handling for scene initialization
        try {
            // Scene setup
            const scene = new THREE.Scene();
            scene.userData.galleryWidth = 20 * 5;  // Scaled up 5x
            scene.userData.galleryLength = 100 * 5;  // Scaled up 5x
            scene.userData.galleryHeight = 8 * 5;  // Scaled up 5x
            const wallThickness = 0.2 * 5;
            const corridorWidth = 6 * 5;
            
            // Create a shared texture loader at the top
            const textureLoader = new THREE.TextureLoader();
            
            // Scene setup
            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                antialias: isMobile ? false : true,
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            
            // Add error display element
            const errorDisplay = document.createElement('div');
            errorDisplay.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 8px;
                max-width: 90%;
                z-index: 1000;
                display: none;
            `;
            document.body.appendChild(errorDisplay);

            // Enhanced error handling
            window.addEventListener('error', (event) => {
                console.error('Error:', event.message);
                errorDisplay.style.display = 'block';
                errorDisplay.innerHTML = `
                    <h2 style="color: #ff4444; margin: 0 0 10px 0;">Error Loading Gallery</h2>
                    <p style="margin: 0 0 10px 0;">${event.message}</p>
                    <p style="margin: 0 0 10px 0;">Please try:</p>
                    <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                        <li>Refreshing the page</li>
                        <li>Using a different browser</li>
                        <li>Checking your internet connection</li>
                    </ul>
                    <button onclick="location.reload()" style="
                        background: #4CAF50;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Refresh Page</button>
                `;
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('scene-container').appendChild(renderer.domElement);
            
            // Remove loading indicator after renderer is ready
            loadingIndicator.style.display = 'none';
            
            // Movement and controls
            const controls = new GalleryControls(camera, scene);
            controls.setupEventListeners();
            
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            let prevTime = performance.now();
            let walkCycle = 0;  // For bobbing motion

            // Train system setup
            const trainSystem = {
                carts: [],
                track: null,
                speed: 0.05,  // Reduced from 0.1 to 0.05 (2 times slower)
                direction: 1,
                currentPosition: 0
            };
            
            // Current artwork display element
            const controlsInfoElement = document.getElementById('controls-info');
            const artworkInfoElement = document.getElementById('artwork-info');
            
            // Load all artwork textures
            const artworkTextures = [];
            for (let i = 1; i <= 19; i++) {
                const texture = textureLoader.load(`images/piece${i}.jpg`, (texture) => {
                    // Enable texture size optimization
                    texture.minFilter = THREE.LinearFilter;
                    texture.generateMipmaps = false;
                    
                    // Limit maximum texture size
                    const maxSize = 1024;  // Reduced from default
                    if (texture.image.width > maxSize || texture.image.height > maxSize) {
                        const scale = Math.min(maxSize / texture.image.width, maxSize / texture.image.height);
                        texture.image.width *= scale;
                        texture.image.height *= scale;
                    }
                    
                    texture.needsUpdate = true;
                });
                texture.colorSpace = THREE.SRGBColorSpace;
                artworkTextures.push(texture);
            }

            // Create a fallback texture in case images fail to load
            function createFallbackTexture(width, height, index) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext('2d');
                
                // Fill background
                context.fillStyle = '#cccccc';
                context.fillRect(0, 0, width, height);
                
                // Add text
                context.fillStyle = '#666666';
                context.font = '30px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`Piece ${index + 1}`, width/2, height/2);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;
                return texture;
            }
            
            // Update artwork titles with descriptions
            const artworkTitles = [];
            for (let i = 1; i <= 19; i++) {
                artworkTitles.push(artworkDescriptions[i-1] || `Piece ${i}`);
            }
            
            // NPCs
            const npcs = [];
            const npcCount = 24;  // Increased from 12 to 24 NPCs

            function createCuteMinecraftVillager() {
                const group = new THREE.Group();
                const scale = 0.5;  // Half the original size

                // Give each group some random colors
                const skinColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                const clothesColor = new THREE.Color(Math.random(), Math.random(), Math.random());

                const headGeometry = new THREE.BoxGeometry(1 * scale, 1 * scale, 1 * scale);
                const headMaterial = new THREE.MeshBasicMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 0.8 * scale;
                group.add(head);

                const bodyGeometry = new THREE.BoxGeometry(0.8 * scale, 0.8 * scale, 0.5 * scale);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: clothesColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0;
                group.add(body);

                const armGeometry = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.55 * scale, 0, 0);
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.55 * scale, 0, 0);
                group.add(rightArm);

                const legGeometry = new THREE.BoxGeometry(0.3 * scale, 0.5 * scale, 0.3 * scale);
                const pantsMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(clothesColor).multiplyScalar(0.7)
                });
                const leftLeg = new THREE.Mesh(legGeometry, pantsMaterial);
                leftLeg.position.set(-0.2 * scale, -0.65 * scale, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeometry, pantsMaterial);
                rightLeg.position.set(0.2 * scale, -0.65 * scale, 0);
                group.add(rightLeg);

                // Add random walking style parameters
                group.userData.walkStyle = {
                    frequency: 0.8 + Math.random() * 0.4,  // Random walking speed
                    legAmplitude: 0.3 + Math.random() * 0.4,  // Random leg swing
                    armAmplitude: 0.2 + Math.random() * 0.5,  // Random arm swing
                    bodyTilt: (Math.random() - 0.5) * 0.1,  // Slight random body tilt
                    headBob: 0.05 + Math.random() * 0.1,  // Random head bobbing
                    swayAmount: Math.random() * 0.1  // Random side-to-side sway
                };

                return group;
            }

            function createNPC() {
                const npc = createCuteMinecraftVillager();
                
                // Random starting position within the gallery
                const x = (Math.random() - 0.5) * (scene.userData.galleryWidth - 2);
                const z = -scene.userData.galleryLength / 2 + 5 + Math.random() * (scene.userData.galleryLength - 10);
                npc.position.set(x, 0.65, z);  // Adjusted Y position for smaller size
                
                // Add random movement properties
                npc.userData.velocity = new THREE.Vector3();
                npc.userData.direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    0,
                    Math.random() - 0.5
                ).normalize();
                npc.userData.speed = 0.2 + Math.random() * 0.5;  // More varied speeds
                npc.userData.changeDirectionTime = Math.random() * 8000;
                npc.userData.lastDirectionChange = performance.now();
                npc.userData.walkCycle = Math.random() * Math.PI * 2;
                npc.userData.pauseTime = 0;  // For random pausing
                npc.userData.isPaused = false;
                
                scene.add(npc);
                npcs.push(npc);
                return npc;
            }

            // Create initial NPCs
            for (let i = 0; i < npcCount; i++) {
                createNPC();
            }

            function updateNPCs(time) {
                for (const npc of npcs) {
                    // Random pausing behavior
                    if (!npc.userData.isPaused) {
                        if (Math.random() < 0.001) {  // Small chance to pause
                            npc.userData.isPaused = true;
                            npc.userData.pauseTime = time + Math.random() * 3000;  // Pause for 0-3 seconds
                        }
                    } else if (time > npc.userData.pauseTime) {
                        npc.userData.isPaused = false;
                    }

                    if (!npc.userData.isPaused) {
                        // Change direction randomly or when near walls
                        if (time - npc.userData.lastDirectionChange > npc.userData.changeDirectionTime) {
                            const angle = Math.random() * Math.PI * 2;
                            npc.userData.direction.set(
                                Math.cos(angle),
                                0,
                                Math.sin(angle)
                            ).normalize();
                            npc.userData.changeDirectionTime = 3000 + Math.random() * 8000;
                            npc.userData.lastDirectionChange = time;
                        }
                        
                        // Calculate new position
                        const newPosition = npc.position.clone();
                        newPosition.x += npc.userData.direction.x * npc.userData.speed * 0.02;
                        newPosition.z += npc.userData.direction.z * npc.userData.speed * 0.02;
                        
                        // Boundary checks using gallery dimensions
                        const margin = 1;
                        const maxX = scene.userData.galleryWidth/2 - margin;
                        const maxZ = scene.userData.galleryLength/2 - margin;
                        
                        // Clamp position to gallery boundaries
                        newPosition.x = Math.max(-maxX, Math.min(maxX, newPosition.x));
                        newPosition.z = Math.max(-maxZ, Math.min(maxZ, newPosition.z));
                        
                        // Update position and rotation
                            npc.position.copy(newPosition);
                            npc.rotation.y = Math.atan2(npc.userData.direction.x, npc.userData.direction.z);
                            
                            // Apply walking style
                            const style = npc.userData.walkStyle;
                            npc.userData.walkCycle += style.frequency * 0.1;
                            
                            // Leg animation with unique style
                            const leftLeg = npc.children[4];
                            const rightLeg = npc.children[5];
                            leftLeg.rotation.x = Math.sin(npc.userData.walkCycle) * style.legAmplitude;
                            rightLeg.rotation.x = Math.sin(npc.userData.walkCycle + Math.PI) * style.legAmplitude;
                            
                            // Arm animation with unique style
                            const leftArm = npc.children[2];
                            const rightArm = npc.children[3];
                            leftArm.rotation.x = Math.sin(npc.userData.walkCycle + Math.PI) * style.armAmplitude;
                            rightArm.rotation.x = Math.sin(npc.userData.walkCycle) * style.armAmplitude;
                            
                            // Body and head movement
                            const body = npc.children[1];
                            const head = npc.children[0];
                            body.rotation.z = Math.sin(npc.userData.walkCycle * 2) * style.swayAmount + style.bodyTilt;
                            head.rotation.x = Math.sin(npc.userData.walkCycle * 2) * style.headBob;
                    } else {
                        // Reset animations while paused
                        npc.children.forEach(part => part.rotation.set(0, 0, 0));
                    }
                }
            }
            
            // Create the gallery environment
            function createGallery() {
                // Floor with meadow appearance
                createFloor();
                
                // Ceiling with pleats
                const pleatWidth = 2 * 5;  // Width of each pleat
                const pleatDepth = 0.2 * 5;  // Reduced depth for more subtle pleats
                const pleatCount = Math.floor(scene.userData.galleryWidth / pleatWidth);
                
                // Create pleated ceiling material
                const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                
                // Create pleated ceiling geometry
                const ceilingGeometry = new THREE.BufferGeometry();
                const vertices = [];
                const uvs = [];
                const indices = [];
                
                // Create vertices for pleated ceiling
                for (let i = 0; i <= pleatCount; i++) {
                    const x = -scene.userData.galleryWidth/2 + i * pleatWidth;
                    const z = -scene.userData.galleryLength/2;
                    
                    // Top vertex
                    vertices.push(x, scene.userData.galleryHeight, z);
                    uvs.push(i / pleatCount, 0);
                    
                    // Bottom vertex (with pleat)
                    vertices.push(x, scene.userData.galleryHeight - pleatDepth, z);
                    uvs.push(i / pleatCount, 1);
                }
                
                // Create triangles for pleated ceiling
                for (let i = 0; i < pleatCount; i++) {
                    const baseIndex = i * 2;
                    // First triangle
                    indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
                    // Second triangle
                    indices.push(baseIndex + 1, baseIndex + 3, baseIndex + 2);
                }
                
                // Extend the pleats along the length of the gallery
                const lengthSegments = Math.floor(scene.userData.galleryLength / pleatWidth);
                for (let j = 1; j <= lengthSegments; j++) {
                    const z = -scene.userData.galleryLength/2 + j * pleatWidth;
                    for (let i = 0; i <= pleatCount; i++) {
                        const x = -scene.userData.galleryWidth/2 + i * pleatWidth;
                        
                        // Top vertex
                        vertices.push(x, scene.userData.galleryHeight, z);
                        uvs.push(i / pleatCount, j / lengthSegments);
                        
                        // Bottom vertex (with pleat)
                        vertices.push(x, scene.userData.galleryHeight - pleatDepth, z);
                        uvs.push(i / pleatCount, j / lengthSegments);
                    }
                    
                    // Create triangles for this segment
                    const baseIndex = (j - 1) * (pleatCount + 1) * 2;
                    for (let i = 0; i < pleatCount; i++) {
                        const segmentBaseIndex = baseIndex + i * 2;
                        // First triangle
                        indices.push(segmentBaseIndex, segmentBaseIndex + 1, segmentBaseIndex + 2);
                        // Second triangle
                        indices.push(segmentBaseIndex + 1, segmentBaseIndex + 3, segmentBaseIndex + 2);
                    }
                }
                
                ceilingGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                ceilingGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                ceilingGeometry.setIndex(indices);
                ceilingGeometry.computeVertexNormals();
                
                const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                ceiling.receiveShadow = true;
                scene.add(ceiling);
                
                // Walls
                createWalls();
                
                // Artworks
                placeArtworks();
                
                // Lights
                createLights();
                
                // Add railway system
                createRailwaySystem();
            }
            
            function createFloor() {
                const floorGeometry = new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryLength);
                const textureLoader = new THREE.TextureLoader();
                const woodTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
                woodTexture.wrapS = THREE.RepeatWrapping;
                woodTexture.wrapT = THREE.RepeatWrapping;
                woodTexture.repeat.set(40, 40);  // Increased from 8,8 to 40,40 for 5x smaller pattern
                
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                scene.add(floor);
            }
            
            function createWalls() {
                const wallMaterial = new THREE.MeshStandardMaterial({
                    map: textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg'),
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });

                // Create back wall
                const backWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryHeight),
                    wallMaterial
                );
                backWall.position.set(0, scene.userData.galleryHeight/2, -scene.userData.galleryLength/2);
                backWall.receiveShadow = true;
                backWall.material.map.repeat.set(40, 40);
                scene.add(backWall);

                // Create side walls
                const leftWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(scene.userData.galleryLength, scene.userData.galleryHeight),
                    wallMaterial
                );
                leftWall.position.x = -scene.userData.galleryWidth/2;
                leftWall.position.y = scene.userData.galleryHeight/2;
                leftWall.rotation.y = Math.PI/2;
                leftWall.receiveShadow = true;
                leftWall.material.map.repeat.set(40, 40);
                scene.add(leftWall);

                const rightWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(scene.userData.galleryLength, scene.userData.galleryHeight),
                    wallMaterial
                );
                rightWall.position.x = scene.userData.galleryWidth/2;
                rightWall.position.y = scene.userData.galleryHeight/2;
                rightWall.rotation.y = -Math.PI/2;
                rightWall.receiveShadow = true;
                rightWall.material.map.repeat.set(40, 40);
                scene.add(rightWall);

                // Create front wall
                const frontWall = new THREE.Mesh(
                    new THREE.PlaneGeometry(scene.userData.galleryWidth, scene.userData.galleryHeight),
                    wallMaterial
                );
                frontWall.position.set(0, scene.userData.galleryHeight/2, scene.userData.galleryLength/2);
                frontWall.receiveShadow = true;
                frontWall.material.map.repeat.set(40, 40);
                scene.add(frontWall);
            }
            
            function createFramedArtwork(texture, width, height, title, index) {
                // Create group for the artwork
                const artworkGroup = new THREE.Group();
                const artworkInfo = parseArtworkDescription(index);
                artworkGroup.userData = { 
                    title: artworkInfo.title,
                    index: index,
                    description: artworkInfo.description
                };
                
                // Create artwork with improved material settings
                const artworkGeometry = new THREE.PlaneGeometry(width, height);
                const artworkMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 1
                });
                const artwork = new THREE.Mesh(artworkGeometry, artworkMaterial);
                artworkGroup.add(artwork);
                
                // Create description sign
                const signGroup = createDescriptionSign(artworkInfo.title, artworkInfo.description);
                signGroup.position.set(0, -height/2 - 1.2, 0.02); // Position lower
                artworkGroup.add(signGroup);
                
                return artworkGroup;
            }
            
            // Function to create 3D text sign
            function createDescriptionSign(title, description) {
                const signGroup = new THREE.Group();
                
                // Create sign background
                const signWidth = 2.5;
                const signHeight = 1.5;
                const signThickness = 0.05;
                const signGeometry = new THREE.BoxGeometry(signWidth, signHeight, signThickness);
                const signMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const signBackground = new THREE.Mesh(signGeometry, signMaterial);
                signBackground.position.z = -signThickness/2;
                signGroup.add(signBackground);
                
                // Create text geometry for both sides
                const textGeometry = new THREE.PlaneGeometry(signWidth - 0.1, signHeight - 0.1);
                
                // Create front text canvas
                const frontCanvas = document.createElement('canvas');
                const frontCtx = frontCanvas.getContext('2d');
                frontCanvas.width = 512;
                frontCanvas.height = 256;
                
                // Draw white background
                frontCtx.fillStyle = 'white';
                frontCtx.fillRect(0, 0, frontCanvas.width, frontCanvas.height);
                
                // Add border
                frontCtx.strokeStyle = 'black';
                frontCtx.lineWidth = 4;
                frontCtx.strokeRect(8, 8, frontCanvas.width - 16, frontCanvas.height - 16);
                
                // Draw title
                frontCtx.font = 'bold 28px Arial';
                frontCtx.fillStyle = 'black';
                frontCtx.textAlign = 'center';
                frontCtx.textBaseline = 'top';
                frontCtx.fillText(title, frontCanvas.width / 2, 24);
                
                // Draw description with word wrapping
                frontCtx.font = '20px Arial';
                frontCtx.textAlign = 'left';
                frontCtx.textBaseline = 'top';
                
                const maxWidth = frontCanvas.width - 48;
                const lineHeight = 24;
                const startY = 70;
                
                wrapText(frontCtx, description, 24, startY, maxWidth, lineHeight);
                
                // Create back text canvas (mirrored)
                const backCanvas = document.createElement('canvas');
                const backCtx = backCanvas.getContext('2d');
                backCanvas.width = 512;
                backCanvas.height = 256;
                
                // Draw white background
                backCtx.fillStyle = 'white';
                backCtx.fillRect(0, 0, backCanvas.width, backCanvas.height);
                
                // Add border
                backCtx.strokeStyle = 'black';
                backCtx.lineWidth = 4;
                backCtx.strokeRect(8, 8, backCanvas.width - 16, backCanvas.height - 16);
                
                // Draw title (mirrored)
                backCtx.font = 'bold 28px Arial';
                backCtx.fillStyle = 'black';
                backCtx.textAlign = 'center';
                backCtx.textBaseline = 'top';
                backCtx.fillText(title, backCanvas.width / 2, 24);
                
                // Draw description with word wrapping (mirrored)
                backCtx.font = '20px Arial';
                backCtx.textAlign = 'left';
                backCtx.textBaseline = 'top';
                
                wrapText(backCtx, description, 24, startY, maxWidth, lineHeight);
                
                // Create textures from canvases
                const frontTexture = new THREE.CanvasTexture(frontCanvas);
                frontTexture.needsUpdate = true;
                
                const backTexture = new THREE.CanvasTexture(backCanvas);
                backTexture.needsUpdate = true;
                
                // Create two planes for text (front and back)
                const frontTextMaterial = new THREE.MeshBasicMaterial({ 
                    map: frontTexture,
                    transparent: false,
                    side: THREE.DoubleSide
                });
                const frontTextMesh = new THREE.Mesh(textGeometry, frontTextMaterial);
                frontTextMesh.position.z = -signThickness/2 + 0.01;
                signGroup.add(frontTextMesh);
                
                // Back text plane
                const backTextMaterial = new THREE.MeshBasicMaterial({ 
                    map: backTexture,
                    transparent: false,
                    side: THREE.DoubleSide
                });
                const backTextMesh = new THREE.Mesh(textGeometry, backTextMaterial);
                backTextMesh.position.z = signThickness/2 - 0.01;
                signGroup.add(backTextMesh);
                
                return signGroup;
            }
            
            // Helper function to wrap text
            function wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                let testLine = '';
                let lineCount = 0;
                
                for (let n = 0; n < words.length; n++) {
                    testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;
                    
                    if (testWidth > maxWidth && n > 0) {
                        context.fillText(line, x, y + (lineCount * lineHeight));
                        line = words[n] + ' ';
                        lineCount++;
                    } else {
                        line = testLine;
                    }
                }
                
                context.fillText(line, x, y + (lineCount * lineHeight));
            }
            
            function placeArtworks() {
                const artworks = [];
                const artworkWidth = 3.5 * 5;    // Scaled up 5x
                const artworkHeight = 4.5 * 5;   // Scaled up 5x
                const artworkSpacing = 8 * 5;    // Scaled up 5x
                const artworkWallOffset = 0.12 * 5; // Scaled up 5x
                const artworkYPosition = artworkHeight / 2 + 3;  // Increased from 2.8 to 3
                
                // Place artworks on left wall (facing right)
                for (let i = 0; i < 9; i++) {
                    const artwork = createFramedArtwork(
                        artworkTextures[i] || createFallbackTexture(600, 800, i), 
                        artworkWidth, 
                        artworkHeight, 
                        artworkTitles[i],
                        i
                    );
                    
                    const zPos = -scene.userData.galleryLength / 2 + 10 + i * artworkSpacing;
                    
                    artwork.position.set(
                        -scene.userData.galleryWidth / 2 + artworkWallOffset + 0.001, 
                        artworkYPosition, 
                        zPos
                    );
                    
                    artwork.rotation.y = Math.PI / 2;  // Rotate to face right
                    scene.add(artwork);
                    artworks.push(artwork);
                }
                
                // Place artworks on right wall (facing left)
                for (let i = 0; i < 10; i++) {
                    const artwork = createFramedArtwork(
                        artworkTextures[i + 9] || createFallbackTexture(600, 800, i + 9), 
                        artworkWidth, 
                        artworkHeight, 
                        artworkTitles[i + 9],
                        i + 9
                    );
                    
                    const zPos = -scene.userData.galleryLength / 2 + 10 + i * artworkSpacing;
                    
                    artwork.position.set(
                        scene.userData.galleryWidth / 2 - artworkWallOffset - 0.001, 
                        artworkYPosition, 
                        zPos
                    );
                    
                    artwork.rotation.y = -Math.PI / 2;  // Rotate to face left
                    scene.add(artwork);
                    artworks.push(artwork);
                }
                
                return artworks;
            }
            
            function createLights() {
                // Ambient light - increased intensity
                const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);  // Increased from 0.5 to 1.0
                scene.add(ambientLight);
                
                // Add fewer spotlights to light the gallery (to reduce shader complexity)
                const spotlightColor = 0xffffff;
                const spotlightIntensity = 5;  // Increased from 3 to 5
                const spotlightDistance = 30;  // Increased from 20 to 30
                const spotlightAngle = Math.PI / 4;  // Widened angle
                const spotlightPenumbra = 0.7;  // Increased softness
                
                // Use fewer spotlights - just 3 per wall to reduce shader complexity
                // Left wall spotlights
                const leftPositions = [-scene.userData.galleryLength / 3, 0, scene.userData.galleryLength / 3];
                for (let i = 0; i < leftPositions.length; i++) {
                    const zPos = leftPositions[i];
                    
                    const spotlight = new THREE.SpotLight(
                        spotlightColor, 
                        spotlightIntensity, 
                        spotlightDistance, 
                        spotlightAngle, 
                        spotlightPenumbra
                    );
                    
                    spotlight.position.set(-scene.userData.galleryWidth / 2 + 2, scene.userData.galleryHeight - 0.5, zPos);
                    spotlight.target.position.set(-scene.userData.galleryWidth / 2 + 0.1, 0, zPos);  // Point lower
                    
                    spotlight.castShadow = true;
                    spotlight.shadow.bias = -0.0001;
                    spotlight.shadow.mapSize.width = 1024;  // Increased shadow quality
                    spotlight.shadow.mapSize.height = 1024;
                    
                    scene.add(spotlight);
                    scene.add(spotlight.target);
                }
                
                // Right wall spotlights
                const rightPositions = [-scene.userData.galleryLength / 3, 0, scene.userData.galleryLength / 3];
                for (let i = 0; i < rightPositions.length; i++) {
                    const zPos = rightPositions[i];
                    
                    const spotlight = new THREE.SpotLight(
                        spotlightColor, 
                        spotlightIntensity, 
                        spotlightDistance, 
                        spotlightAngle, 
                        spotlightPenumbra
                    );
                    
                    spotlight.position.set(scene.userData.galleryWidth / 2 - 2, scene.userData.galleryHeight - 0.5, zPos);
                    spotlight.target.position.set(scene.userData.galleryWidth / 2 - 0.1, 0, zPos);  // Point lower
                    
                    spotlight.castShadow = true;
                    spotlight.shadow.bias = -0.0001;
                    spotlight.shadow.mapSize.width = 1024;  // Increased shadow quality
                    spotlight.shadow.mapSize.height = 1024;
                    
                    scene.add(spotlight);
                    scene.add(spotlight.target);
                }
                
                // Simplify the main lighting - use a hemispherical light instead of directional
                const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x404040, 1.2);  // Increased from 0.8 to 1.2
                scene.add(hemisphereLight);
            }
            
            // Add train and railway system
            function createRailwaySystem() {
                // Create railway track
                const trackGeometry = new THREE.BoxGeometry(2, 0.1, scene.userData.galleryLength);
                const trackMaterial = new THREE.MeshStandardMaterial({
                    map: textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg'),
                    roughness: 0.7,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                const track = new THREE.Mesh(trackGeometry, trackMaterial);
                track.position.set(0, 0.05, 0);
                scene.add(track);
                trainSystem.track = track;

                // Create railway sleepers
                const sleeperGeometry = new THREE.BoxGeometry(4, 0.1, 0.4);
                const sleeperMaterial = new THREE.MeshStandardMaterial({
                    map: textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg'),
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });

                for (let z = -scene.userData.galleryLength/2 + 2; z < scene.userData.galleryLength/2 - 2; z += 2) {
                    const sleeper = new THREE.Mesh(sleeperGeometry, sleeperMaterial);
                    sleeper.position.set(0, 0.02, z);
                    scene.add(sleeper);
                }

                // Create minecart train with 20 carts
                const cartSpacing = 2.5;  // Reduced spacing between carts
                for (let i = 0; i < 20; i++) {  // Changed from 10 to 20 carts
                    const cart = createMinecart();
                    cart.position.z = -scene.userData.galleryLength/2 + 5 + (i * cartSpacing);
                    trainSystem.carts.push(cart);
                    scene.add(cart);
                }

                // Update function for train movement
                trainSystem.update = function() {
                    trainSystem.carts.forEach((cart, index) => {
                        // Move cart forward continuously
                        cart.position.z += trainSystem.speed;

                        // Implement room wrapping for train
                        const galleryLength = scene.userData.galleryLength;
                        const margin = 1; // Small margin to prevent getting stuck at edges

                        // Wrap Z position
                        if (cart.position.z > galleryLength/2 + margin) {
                            cart.position.z = -galleryLength/2 - margin;
                        } else if (cart.position.z < -galleryLength/2 - margin) {
                            cart.position.z = galleryLength/2 + margin;
                        }

                        // Rotate wheels continuously
                        cart.children.slice(3).forEach(wheel => {
                            wheel.rotation.x += 0.1 * trainSystem.speed;  // Simple wheel rotation
                        });

                        // Update camera if riding this cart
                        if (camera.userData.onTrain === cart) {
                            camera.position.x = cart.position.x;
                            camera.position.y = cart.position.y + 1.5;
                            camera.position.z = cart.position.z;
                        }
                    });
                };
            }

            function createMinecart() {
                const cartGroup = new THREE.Group();

                // Cart base
                const baseGeometry = new THREE.BoxGeometry(2, 0.5, 2);
                const baseMaterial = new THREE.MeshStandardMaterial({
                    map: textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg'),
                    roughness: 0.8,
                    metalness: 0.1,
                    color: 0xD2B48C,  // Tan color - more beige than brown
                    side: THREE.DoubleSide
                });
                baseMaterial.map.repeat.set(4, 4);  // Smaller wood pattern for the cart
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.5;
                cartGroup.add(base);

                // Cart sides
                const sideGeometry = new THREE.BoxGeometry(0.1, 0.5, 2);
                const sideMaterial = new THREE.MeshStandardMaterial({
                    map: textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg'),
                    roughness: 0.8,
                    metalness: 0.1,
                    color: 0xD2B48C,  // Tan color - more beige than brown
                    side: THREE.DoubleSide
                });
                sideMaterial.map.repeat.set(4, 4);  // Smaller wood pattern for the sides

                const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
                leftSide.position.set(-0.95, 1, 0);
                cartGroup.add(leftSide);

                const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
                rightSide.position.set(0.95, 1, 0);
                cartGroup.add(rightSide);

                // Cart wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                const wheelMaterial = new THREE.MeshStandardMaterial({
                    map: textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg'),
                    roughness: 0.8,
                    metalness: 0.1,
                    color: 0xBC8F8F,  // Rosy brown - lighter and less reddish
                    side: THREE.DoubleSide
                });
                wheelMaterial.map.repeat.set(4, 4);  // Smaller wood pattern for the wheels
                
                const wheelPositions = [
                    [-0.8, 0.3, -0.8],
                    [0.8, 0.3, -0.8],
                    [-0.8, 0.3, 0.8],
                    [0.8, 0.3, 0.8]
                ];

                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(...pos);
                    wheel.name = 'wheel';
                    cartGroup.add(wheel);
                });

                return cartGroup;
            }
            
            function checkCollisions(position) {
                // Create a box representing the player
                const playerSize = 0.5;  // Half-width of player
                const playerHeight = 1.8;  // Height of player
                
                const playerMin = new THREE.Vector3(
                    position.x - playerSize,
                    position.y,
                    position.z - playerSize
                );
                
                const playerMax = new THREE.Vector3(
                    position.x + playerSize,
                    position.y + playerHeight,
                    position.z + playerSize
                );
                
                // Check collision with each wall
                for (const wall of collisionWalls) {
                    // Check for intersection
                    if (
                        playerMax.x > wall.min.x && playerMin.x < wall.max.x &&
                        playerMax.y > wall.min.y && playerMin.y < wall.max.y &&
                        playerMax.z > wall.min.z && playerMin.z < wall.max.z
                    ) {
                        return true;  // Collision detected
                    }
                }
                
                return false;  // No collision
            }
            
            // Set initial camera position (randomly positioned in front of an artwork)
            function setRandomInitialPosition() {
                // Decide which wall (left or right) randomly
                const isLeftWall = Math.random() < 0.5;
                
                // Calculate a random position along the wall
                const zPos = -scene.userData.galleryLength / 2 + 10 + Math.floor(Math.random() * 9) * (8 * 5);
                
                // Position camera in the middle of the corridor (x = 0)
                const xPos = 0;  // Middle of the corridor
                
                // Position camera
                camera.position.set(xPos, 0.8, zPos);
                
                // Make camera face the chosen wall
                if (isLeftWall) {
                    camera.lookAt(new THREE.Vector3(-scene.userData.galleryWidth / 2, 0.8, zPos));
                } else {
                    camera.lookAt(new THREE.Vector3(scene.userData.galleryWidth / 2, 0.8, zPos));
                }
            }

            // Initialize gallery, controls, and set random position
            createGallery();
            const galleryControls = new GalleryControls(camera, scene);
            setRandomInitialPosition();

            // Add click handler to remove welcome popup when clicking anywhere
                const welcomePopup = document.getElementById('welcome-popup');
            document.addEventListener('click', function() {
                    welcomePopup.style.opacity = '0';
                welcomePopup.style.transform = 'translate(-50%, -50%)';
                    setTimeout(() => {
                        welcomePopup.style.display = 'none';
                }, 300);
            }, { once: true });  // The 'once: true' option ensures the event only fires once

                // Handle window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Add train boarding event listener
                document.addEventListener('keydown', (event) => {
                    if (event.code === 'KeyE') {
                        const playerPos = camera.position;
                        let nearestCart = null;
                        let shortestDistance = Infinity;

                        // Check if train system and carts exist
                        if (!trainSystem || !trainSystem.carts || trainSystem.carts.length === 0) {
                            return;
                        }

                        trainSystem.carts.forEach(cart => {
                            if (!cart) return;
                            
                            const cartPos = cart.position;
                            const distance = Math.sqrt(
                                Math.pow(playerPos.x - cartPos.x, 2) +
                                Math.pow(playerPos.z - cartPos.z, 2)
                            );

                            if (distance < shortestDistance) {
                                shortestDistance = distance;
                                nearestCart = cart;
                            }
                        });

                        if (shortestDistance < 3 && nearestCart) {  // Check if nearestCart exists
                            if (!camera.userData.onTrain) {
                                // Board train
                                camera.userData.onTrain = nearestCart;
                                camera.position.x = nearestCart.position.x + 0.5;
                                camera.position.y = nearestCart.position.y + 1.2;
                                camera.position.z = nearestCart.position.z;
                                if (artworkInfoElement) {
                                artworkInfoElement.innerHTML = "<strong>Press E to exit train</strong>";
                                artworkInfoElement.style.display = 'block';
                                }
                            } else {
                                // Exit train
                                camera.userData.onTrain = null;
                                camera.position.x = nearestCart.position.x + 2;
                                if (artworkInfoElement) {
                                artworkInfoElement.style.display = 'none';
                                }
                            }
                        }
                    }
                });
                
            // Add performance monitoring
            let frameCount = 0;
            let lastFPSUpdate = performance.now();
            
            function updateFPS() {
                const now = performance.now();
                const delta = now - lastFPSUpdate;
                
                if (delta >= 1000) {
                    frameCount = 0;
                    lastFPSUpdate = now;
                }
            }
            
            // Add movement update interval tracking
            let lastMovementUpdate = 0;
            const MOVEMENT_UPDATE_INTERVAL = 20; // 20ms = 0.02 seconds

            function animate() {
                requestAnimationFrame(animate);
                
                // Skip update if tab is hidden
                if (document.hidden) return;
                
                const time = performance.now();
                frameCount++;
                updateFPS();
                
                // Update NPCs
                updateNPCs(time);
                
                // Update train system
                if (trainSystem) {
                    trainSystem.update();
                }
                
                // Update camera position if on train
                if (camera.userData.onTrain) {
                    camera.position.z = camera.userData.onTrain.position.z;
                }
                
                // Update movement if active
                if (camera.userData.movement && time - lastMovementUpdate >= MOVEMENT_UPDATE_INTERVAL) {
                    const speed = 0.5; // Base movement speed
                    const movement = camera.userData.movement;
                    
                    // Update camera position based on stored movement values
                    camera.position.x += movement.x * speed * movement.distance;
                    camera.position.z += movement.z * speed * movement.distance;
                    camera.position.y = 0.8; // Keep constant height
                    
                    lastMovementUpdate = time;
                }
                
                // Update controls with mobile input
                galleryControls.update();
                
                renderer.render(scene, camera);
            }
            
            // Track multiple touches
            let activeTouches = new Map();
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouching = false;
            const touchAreaRadius = 100; // Radius of the circular touch areas
            const touchAreaMargin = 20; // Margin from screen edges

            // Create visual indicators for touch areas
            const cameraTouchArea = document.createElement('div');
            cameraTouchArea.style.cssText = `
                position: fixed;
                bottom: ${touchAreaMargin}px;
                right: ${touchAreaMargin}px;
                width: ${touchAreaRadius * 2}px;
                height: ${touchAreaRadius * 2}px;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                pointer-events: none;
                z-index: 1000;
                display: none;
            `;
            document.body.appendChild(cameraTouchArea);

            const movementTouchArea = document.createElement('div');
            movementTouchArea.style.cssText = `
                position: fixed;
                bottom: ${touchAreaMargin}px;
                left: ${touchAreaMargin}px;
                width: ${touchAreaRadius * 2}px;
                height: ${touchAreaRadius * 2}px;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                pointer-events: none;
                z-index: 1000;
                display: none;
            `;
            document.body.appendChild(movementTouchArea);

            // Show indicators on mobile devices
            if (isMobile) {
                cameraTouchArea.style.display = 'block';
                movementTouchArea.style.display = 'block';
            }

            // Helper function to check if touch is within the camera control area
            function isTouchInCameraArea(touchX, touchY) {
                const centerX = window.innerWidth - touchAreaMargin - touchAreaRadius;
                const centerY = window.innerHeight - touchAreaMargin - touchAreaRadius;
                const distance = Math.sqrt(
                    Math.pow(touchX - centerX, 2) + 
                    Math.pow(touchY - centerY, 2)
                );
                return distance <= touchAreaRadius;
            }

            // Helper function to check if touch is within the movement control area
            function isTouchInMovementArea(touchX, touchY) {
                const centerX = touchAreaMargin + touchAreaRadius;
                const centerY = window.innerHeight - touchAreaMargin - touchAreaRadius;
                const distance = Math.sqrt(
                    Math.pow(touchX - centerX, 2) + 
                    Math.pow(touchY - centerY, 2)
                );
                return distance <= touchAreaRadius;
            }

            document.addEventListener('touchstart', (event) => {
                // Prevent default touch behavior
                        event.preventDefault();
                
                // Handle each new touch
                for (const touch of event.touches) {
                    const touchId = touch.identifier;
                    
                    // Determine which area is being touched
                    if (isTouchInMovementArea(touch.clientX, touch.clientY)) {
                        activeTouches.set(touchId, {
                            type: 'movement',
                            startX: touch.clientX,
                            startY: touch.clientY,
                            currentX: touch.clientX,
                            currentY: touch.clientY
                        });
                        movementTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                        if (!galleryControls.isLocked) {
                            galleryControls.lock();
                        }
                    } else if (isTouchInCameraArea(touch.clientX, touch.clientY)) {
                        activeTouches.set(touchId, {
                            type: 'camera',
                            startX: touch.clientX,
                            startY: touch.clientY,
                            currentX: touch.clientX,
                            currentY: touch.clientY
                        });
                        if (!galleryControls.isLocked) {
                            galleryControls.lock();
                        }
                        cameraTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                    }
                }
            });

            document.addEventListener('touchmove', (event) => {
                // Prevent default touch behavior
                event.preventDefault();
                
                // Handle each active touch
                for (const touch of event.touches) {
                    const touchId = touch.identifier;
                    const touchData = activeTouches.get(touchId);
                    
                    if (!touchData) continue;
                    
                    // Update current position
                    touchData.currentX = touch.clientX;
                    touchData.currentY = touch.clientY;
                    
                    // Calculate delta movement
                    const deltaX = touchData.currentX - touchData.startX;
                    const deltaY = touchData.currentY - touchData.startY;
                    
                    if (touchData.type === 'movement') {
                        // Calculate movement direction based on touch position relative to center
                        const centerX = touchAreaMargin + touchAreaRadius;
                        const centerY = window.innerHeight - touchAreaMargin - touchAreaRadius;
                        const relativeX = touchData.currentX - centerX;
                        const relativeY = touchData.currentY - centerY;
                        
                        // Calculate angle from center to touch position (flipped horizontally)
                        const angle = -Math.atan2(relativeY, relativeX);  // Added negative sign to flip horizontally
                        
                        // Calculate distance from center (0 to 1)
                        const distance = Math.min(1, Math.sqrt(relativeX * relativeX + relativeY * relativeY) / touchAreaRadius);
                        
                        // Get camera's forward direction
                        const cameraForward = new THREE.Vector3(0, 0, -1);
                        cameraForward.applyQuaternion(camera.quaternion);
                        
                        // Create a vector perpendicular to camera's forward direction
                        const cameraRight = new THREE.Vector3(1, 0, 0);
                        cameraRight.applyQuaternion(camera.quaternion);
                        
                        // Calculate movement direction relative to camera
                        const moveX = Math.cos(angle) * cameraRight.x + Math.sin(angle) * cameraForward.x;
                        const moveZ = Math.cos(angle) * cameraRight.z + Math.sin(angle) * cameraForward.z;
                        
                        // Normalize the movement vector
                        const moveLength = Math.sqrt(moveX * moveX + moveZ * moveZ);
                        const normalizedMoveX = moveX / moveLength;
                        const normalizedMoveZ = moveZ / moveLength;
                        
                        // Store the movement values for the animation loop
                        camera.userData.movement = {
                            x: normalizedMoveX,
                            z: normalizedMoveZ,
                            distance: distance
                        };
                    } else if (touchData.type === 'camera') {
                        // Update camera rotation
                        galleryControls.euler.setFromQuaternion(galleryControls.camera.quaternion);
                        galleryControls.euler.y -= deltaX * galleryControls.lookSpeed * 2;
                        galleryControls.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, 
                            galleryControls.euler.x - deltaY * galleryControls.lookSpeed * 2));
                        galleryControls.camera.quaternion.setFromEuler(galleryControls.euler);
                    }
                    
                    // Update start position for next delta calculation
                    touchData.startX = touchData.currentX;
                    touchData.startY = touchData.currentY;
                }
            });

            document.addEventListener('touchend', (event) => {
                // Remove ended touches
                for (const touch of event.changedTouches) {
                    const touchId = touch.identifier;
                    const touchData = activeTouches.get(touchId);
                    
                    if (touchData) {
                        if (touchData.type === 'movement') {
                            movementTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                        } else if (touchData.type === 'camera') {
                            cameraTouchArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                        }
                        activeTouches.delete(touchId);
                    }
                }
                
                // Clear movement data if no movement touches remain
                if (!Array.from(activeTouches.values()).some(touch => touch.type === 'movement')) {
                    camera.userData.movement = null;
                }
                
                // Unlock controls if no touches remain
                if (activeTouches.size === 0 && galleryControls.isLocked) {
                    galleryControls.unlock();
                }
            });
            
                animate();
        } catch (error) {
            console.error('Error initializing gallery:', error);
            document.getElementById('scene-container').innerHTML = `
                <div style="color: white; padding: 20px; text-align: center;">
                    <h2>Error Loading Gallery</h2>
                    <p>Please check the console for details.</p>
                </div>
            `;
        }
    </script>
</body>
</html>